{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PIC16F877a","text":""},{"location":"#pic16f877a-basics-with-mplab-x-ide-and-xc8-compiler","title":"PIC16f877a basics with MPLAB X IDE and XC8 compiler","text":""},{"location":"#1-contents","title":"1. Contents:","text":"<ul> <li>Timer Interrupt</li> <li>Pulse Width Modulation</li> <li>Analog to Digital Conversion</li> <li>Serial Communication</li> <li>Seven Segment Display Control</li> <li>LCD Display Control</li> <li>Stepper Motor Control</li> </ul>"},{"location":"#2-required-softwares","title":"2. Required Softwares","text":"<ul> <li>Download and Install Mplab X IDE</li> <li>Download and Install XC8 compiler</li> <li>Download and Install Proteus Design Suite</li> </ul>"},{"location":"#3-how-to-use","title":"3. How to Use","text":"<ul> <li>All the codes are written based on the pic16f877a Datasheet. The datasheeet provided here contains all the necessary registers and bits descriptions. The <code>Datasheet</code> folder also contains user manual for Mplab X IDE and Pickit3. </li> <li>Source codes are written in <code>main.c</code> file inside the <code>Project Directory</code></li> <li>Simulation Files can be found inside <code>Proteus Simulation</code> directory under <code>Project Directory</code></li> </ul>"},{"location":"#4-running-a-project","title":"4. Running a project:","text":"<ul> <li>Open the project in <code>MPLAB X</code> IDE</li> <li>Open <code>main.c</code> file inside <code>source</code></li> <li>Click on the <code>build</code> icon on the top</li> <li>A <code>.hex</code> file is generated inside <code>Project Folder &gt; dist &gt; default &gt; production &gt; filename.hex</code></li> <li>Open the Simulation file (with a <code>.pdsprj</code> extension) in <code>Proteus</code></li> <li>Double Click on the mcu to bring out the configuration menu</li> <li>Browse and select the <code>.hex</code> file and click Ok</li> <li>Click on the run button at the bottom to simulate</li> </ul>"},{"location":"#5-pic16f877a-pinout-diagram","title":"5. PIC16F877A Pinout Diagram","text":"<p>PIC16F877a is a powerful (200 nanosecond instruction execution) yet easy-to-program (only 35 single word instructions) CMOS FLASH-based 8-bit microcontroller packs Microchip's powerful PIC\u00ae architecture into an 40- or 44-pin package and is upwards compatible with the PIC16C5X, PIC12CXXX and PIC16C7X devices. The PIC16F877A features 256 bytes of <code>EEPROM</code> data memory, self programming, an <code>ICD</code>, 2 <code>Comparators</code>, 8 channels of 10-bit <code>Analog-to-Digital (A/D) converter</code>, 2 <code>capture/compare/PWM</code> functions, the synchronous <code>serial port</code>, Asynchronous Receiver Transmitter <code>(USART)</code>. All of these features make it ideal for more advanced level A/D applications in automotive, industrial, appliances and consumer applications.</p> <p></p>"},{"location":"#6-pickit3-connections","title":"6. Pickit3 Connections","text":"<p>Microchip\u2019s PICkit\u2122 3 In-Circuit Debugger/Programmer uses in-circuit debugging logic incorporated into each chip with Flash memory to provide a low-cost hardware debugger and programmer.</p> <p></p>"},{"location":"#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0. </p>"},{"location":"Analog%20to%20Digital%20Conversion/","title":"ADC - Analog to Digital Conversion","text":"<p>The Analog-to-Digital (A/D) Converter module has five inputs for the 28-pin devices and eight for the 40/44-pin devices. The conversion of an analog input signal results in a corresponding <code>10-bit</code> digital number. The A/D module has high and low-voltage <code>reference input</code> that is software selectable to some combination of VDD, VSS, RA2 or RA3. The A/D converter has a unique feature of being able to operate while the device is in Sleep mode. To operate in Sleep, the A/D clock must be derived from the A/D\u2019s internal RC oscillator.</p> <p>The A/D module has four registers. These registers are: - A/D Result High Register <code>(ADRESH)</code> - A/D Result Low Register <code>(ADRESL)</code> - A/D Control Register 0 <code>(ADCON0)</code> - A/D Control Register 1 <code>(ADCON1)</code></p> <p>Steps in A/D Conversion - Configure <code>ADCON0</code> register to set the clock frequency, set up channels and powering up the A/D module. <pre><code>      ADCON0bits.ADCS = 0b00; // set A/D conversion clock = fosc/2\n      ADCON0bits.CHS = 0b000; // set all adc channels off\n      ADCON0bits.ADON = 0; // a/d module is powered off\n</code></pre> - Configure <code>ADCON1</code> to set the justification of 10bit output (Ouptut is stored in both <code>ADRESH</code> and <code>ADRESL</code>), clock frequency and data direction of analog input pins. <pre><code>      ADCON1bits.ADFM = 1; // set right justification for ADRESH\n      ADCON1bits.ADCS2 = 0; // set A/D conversion clock = fosc/2\n      ADCON1bits.PCFG = 0b0000; // set all pins as adc input \n</code></pre> - Read analog input value <pre><code>      int __adc_read(int adc_channel) {\n          ADCON0bits.ADON = 1; // turn on a/d module\n          ADCON0bits.CHS = adc_channel; // turn on adc channel\n          __delay_ms(10); // wait for capacitors to charge up\n          ADCON0bits.GO = 1; // begin conversion\n          while(ADCON0bits.GO_DONE == 1) {\n              // wait for conversion to finish\n          }\n          int adc_value = (ADRESH &lt;&lt; 8) + (ADRESL);\n          return adc_value;\n      }\n</code></pre></p>"},{"location":"Analog%20to%20Digital%20Conversion/#circuit-diagram","title":"Circuit Diagram","text":""},{"location":"Analog%20to%20Digital%20Conversion/#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0.</p>"},{"location":"LCD%20Display/","title":"LCD Display Control","text":"<p>LCD (Liquid Crystal Display) screen is an electronic display module and find a wide range of applications. A <code>16x2</code> LCD display is very basic module and is very commonly used in various devices and circuits. These modules are preferred over seven segments and other multi segment LEDs. The reasons being: LCDs are economical; easily programmable; have no limitation of displaying special &amp; even custom characters (unlike in seven segments), animations and so on.</p>"},{"location":"LCD%20Display/#1-initialize-the-display","title":"1. Initialize the Display","text":"<ul> <li>Turn on Display by writing 1 to <code>DB3</code></li> <li>Set display by writting 1 to <code>DB2</code></li> <li>Turn on cursor by setting <code>DB1</code> bit</li> <li>Turn on blinking cursor by writting to <code>DB0</code></li> </ul> <pre><code>      DATA_PORT = 0b00001111;\n</code></pre>"},{"location":"LCD%20Display/#2-clear-the-display","title":"2. Clear the display","text":"<ul> <li>Set the <code>DB0</code> bit to clear display</li> </ul> <pre><code>    DATA_PORT = 0b00000001;\n</code></pre>"},{"location":"LCD%20Display/#3-writing-character-to-the-display","title":"3. Writing character to the display","text":"<ul> <li>Set register select <code>RS</code> pin high</li> <li>Put the character in data port</li> </ul> <pre><code>    SETUP_PORT |= (1 &lt;&lt; RS);\n    DATA_PORT = character_ascii_value;\n</code></pre>"},{"location":"LCD%20Display/#4-writting-a-string","title":"4. Writting a String","text":"<ul> <li>Call <code>lcd_write_char</code> function looping through the string</li> </ul> <pre><code>    void lcd_write(char data[]) {\n      int i;\n      for(i=0; i&lt;(strlen(data)); i++) {\n          lcd_write_char(data[i]);\n      }\n    }\n</code></pre>"},{"location":"LCD%20Display/#5-writting-any-changes-to-display","title":"5. Writting any changes to display","text":"<ul> <li>Set <code>EN</code> pin</li> <li>write values to <code>RS</code> or <code>DATA_PORT</code></li> <li>wait for a while</li> <li>clear <code>EN</code> pin</li> </ul>"},{"location":"LCD%20Display/#circuit-diagram","title":"Circuit Diagram","text":""},{"location":"LCD%20Display/#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0.</p>"},{"location":"PWM/","title":"PWM - LED Brightness Control","text":"<p>Pulse Width Modulation <code>(PWM)</code> is a digital signal which is most commonly used in control circuitry. This signal is set high (5v) and low (0v) in a predefined time and speed. The time during which the signal stays high is called the \u201con time\u201d and the time during which the signal stays low is called the \u201coff time\u201d.</p> <p>Duty Cycle of PWM</p> <p>The percentage of time in which the PWM signal remains HIGH (on time) is called as duty cycle. If the signal is always ON it is in 100% duty cycle and if it is always off it is 0% duty cycle.</p> <p><code>Duty Cycle =Turn ON time/ (Turn ON time + Turn OFF time)</code></p> <p></p> <p>Frequency of PWM</p> <p>The frequency of a PWM signal determines how fast a PWM completes one period. One Period is complete ON and OFF of a PWM signal as shown in the above figure.</p>"},{"location":"PWM/#setting-up-pwm-signal","title":"Setting Up PWM signal","text":"<ul> <li>PWM signals can be generated in our PIC Microcontroller by using the CCP (Compare Capture PWM) module. The resolution of our PWM signal is 10-bit, that is for a value of 0  there will be a duty cycle of 0% and for a value of 1024 (2^10) there be a duty cycle of 100%. There are two CCP modules in our PIC MCU (CCP1 And CCP2), this means we can generate two PWM signals on two different pins (pin 17 and 16) simultaneously, in our tutorial we are using CCP1 to generate PWM signals on pin 17.</li> </ul> <p>1. Required Registers</p> <ul> <li><code>CCP1CON</code>  (CCP1 control Register)</li> <li><code>T2CON</code> (Timer 2 Control Register)</li> <li><code>PR2</code>  (Timer 2 modules Period Register)</li> <li><code>CCPR1L</code> (CCP Register 1 Low)</li> </ul> <p>2. Set up PWM2 module</p> <ul> <li><code>T2CON</code> Register:</li> </ul> 7 6 5 4 3 2 1 0 - TOUTPS3 TOUTPS2 TOUTPS1 TOUTPS0 TMR2ON T2CKPS1 T2CKPS0 <pre><code>    void __init_pwm() {\n      TRISCbits.TRISC2 = 0; // set RC2 as output\n      T2CONbits.TMR2ON = 1; // set timer 2 on\n      T2CONbits.T2CKPS = 0b10; // set pre scalar of 16\n      CCP1CONbits.CCP1M = 0b1100; // set PWM mode of operation\n    }\n</code></pre> <p>3. Set PWM Period</p> <ul> <li> <p>Set the PWM period by writing to the <code>PR2</code> register.</p> </li> <li> <p><code>PWM Period = [(PR2) + 1] \u2022 4 \u2022 TOSC \u2022(TMR2 Prescale Value)</code></p> </li> </ul> <pre><code>    void __set_pwm_freq(int f) {\n      PWM_FREQ = f;\n      PWM_PERIOD = 1 / PWM_FREQ;\n      int PR2_value = ((PWM_PERIOD * _XTAL_FREQ) / (4 * PRESCALAR) - 1);\n      PR2 = PR2_value;\n\n    }\n</code></pre> <p>4. Set Duty Cycle</p> <ul> <li>Set the PWM duty cycle by writing to the <code>CCPR1L</code> register and <code>CCP1CON&lt;5:4&gt;</code> bits.</li> <li><code>PWM Duty Cycle =(CCPR1L:CCP1CON&lt;5:4&gt;) \u2022TOSC \u2022 (TMR2 Prescale Value)</code></li> </ul> <pre><code>    void __set_duty_cycle(int duty_cycle) {\n      float dc = (float) duty_cycle / 100;\n      float dc_period = dc * PWM_PERIOD; \n      int reg_value = (int) ((dc_period * _XTAL_FREQ) / PRESCALAR);\n      /*\n       * PWM has 10 bit resolution\n       * 8 bits of MSB is stored in CCPR1L\n       * 2 bits of LSB is stored in CCP1CON(5:4)\n       */\n      CCPR1L = reg_value &gt;&gt; 2; \n      CCP1CONbits.CCP1X = (reg_value &amp; 0b00000001);\n      CCP1CONbits.CCP1Y = (reg_value &amp; 0b00000010);\n    }\n</code></pre>"},{"location":"PWM/#circuit-diagram","title":"Circuit Diagram","text":""},{"location":"PWM/#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0.</p>"},{"location":"Serial%20Communication/","title":"USART - Serial Communication","text":"<p>The Universal Synchronous Asynchronous Receiver Transmitter <code>(USART)</code> module is one of the two serial I/O modules. (USART is also known as a Serial Communications Interface or <code>SCI</code>.) The USART can be configured as a full-duplex asynchronous system that can communicate with peripheral devices, such as CRT terminals and personal computers, or it can be configured as a half-duplex synchronous system that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.</p> <p>The USART can be configured in the following modes: - Asynchronous (full-duplex) - Synchronous \u2013 Master (half-duplex) - Synchronous \u2013 Slave (half-duplex)</p>"},{"location":"Serial%20Communication/#setting-up-usart","title":"Setting Up USART","text":"<p>1. Associated Registers - <code>TXSTA</code> Register:</p> 7 6 5 4 3 2 1 0 CSRC TX9 TXEN SYNC - BRGH TRMT TX9D <ul> <li><code>RCSTA</code> Register:</li> </ul> 7 6 5 4 3 2 1 0 SPEN RX9 SREN CREN ADDEN FERR OERR RX9D <p>2. Configure <code>USART</code> module</p> <ul> <li>Set up <code>TXSTA</code> register</li> </ul> <pre><code>    TXSTAbits.TX9 = 0; // set 8 bit transmission\n    TXSTAbits.TXEN = 1; // enable data transmit\n    TXSTAbits.SYNC = 0; // select asynchronous mode\n    TXSTAbits.BRGH = 1; // set high baud rate\n</code></pre> <ul> <li>Set up <code>RCSTA</code> register</li> </ul> <pre><code>    RCSTAbits.SPEN = 1; // enable serial ports\n    RCSTAbits.RX9 = 0; // select 8 bit reception\n    RCSTAbits.CREN = 1; // enable continuous receive\n</code></pre>"},{"location":"Serial%20Communication/#3-set-the-baud-rate-of-communication","title":"3. Set the <code>BAUD RATE</code> of communication:","text":"<ul> <li><code>Baud Rate = FOSC/(16 (SPBRG + 1))</code></li> </ul> <pre><code>    void __set_baud_rate(int baud_rate) {\n      SPBRG = ((_XTAL_FREQ / 16) / baud_rate) - 1;\n    }\n</code></pre>"},{"location":"Serial%20Communication/#4-writing-a-character","title":"4. Writing a character","text":"<ul> <li>Wait for the previous transmission to complete. When it is completed the <code>TXIF</code> bit is set.</li> <li>Write the character in <code>TXREG</code></li> </ul> <pre><code>    void __write_char(char c) {\n        while(!TXIF) {\n            // wait until byte is sent\n        } \n        TXREG = c; // transmit a bit\n    }\n</code></pre>"},{"location":"Serial%20Communication/#5-writting-a-string","title":"5. Writting a String","text":"<ul> <li>Call the <code>__write_char(c)</code> function everytime looping through the string.</li> </ul> <pre><code>    void __usart_write_ln(char data[]) {\n        int i;\n        for(i=0; i&lt;(strlen(data)); i++) {\n            __write_char(data[i]);\n        }\n        __write_char('\\r');\n    }\n</code></pre>"},{"location":"Serial%20Communication/#circuit-diagram","title":"Circuit Diagram","text":""},{"location":"Serial%20Communication/#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0.</p>"},{"location":"Seven%20Segment%20Display/","title":"Seven Segment Display","text":""},{"location":"Seven%20Segment%20Display/#bcd-to-sven-segment-decoder","title":"BCD to Sven Segment Decoder","text":""},{"location":"Seven%20Segment%20Display/#truth-table","title":"Truth Table","text":""},{"location":"Seven%20Segment%20Display/#writing-to-the-decoder","title":"Writing to the Decoder","text":"<ul> <li>Loop through <code>0-9</code> and write the binary value to the <code>PORT</code></li> </ul> <pre><code>    void display() {\n        int i;\n        for(i=0; i&lt;10; i++) {\n            PORTC = i;\n            __delay_ms(1000);\n        }\n    }\n</code></pre>"},{"location":"Seven%20Segment%20Display/#circuit-diagram","title":"Circuit Diagram","text":""},{"location":"Seven%20Segment%20Display/#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0.</p>"},{"location":"Stepper%20Motor/","title":"Stepper motor control","text":"<p>Stepper motors vary from regular DC motors in that, rather than just spinning in one direction or another, they can spin in very precise increments.</p>"},{"location":"Stepper%20Motor/#basic-operation","title":"Basic Operation","text":""},{"location":"Stepper%20Motor/#bit-writting-sequence","title":"Bit Writting Sequence","text":"A B C D Angle 0 0 0 1 0 0 0 1 1 45 0 0 1 0 90 0 1 1 0 135 0 1 0 0 180 1 1 0 0 225 1 0 0 0 270 1 0 0 1 315 <ul> <li>write values to connected <code>PORT</code></li> </ul> <pre><code>void rotate_motor() {\n    PORTC = 0b00000001;\n    __delay_ms(40);\n    PORTC = 0b00000011;\n    __delay_ms(40);\n    PORTC = 0b00000010;\n    __delay_ms(40);\n    PORTC = 0b00000110;\n    __delay_ms(40);\n    PORTC = 0b00000100;\n    __delay_ms(40);\n    PORTC = 0b00001100;\n    __delay_ms(40);\n    PORTC = 0b00001000;\n    __delay_ms(40);\n}\n</code></pre>"},{"location":"Stepper%20Motor/#circuit-diagram","title":"Circuit Diagram","text":""},{"location":"Stepper%20Motor/#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0.</p>"},{"location":"Timer/","title":"Creating 1Hz pulse using <code>PIC</code> internal timer interrupt","text":"<p>pic16f877a has 3 timers. they are: - Timer0 (8 bit) - Timer1 (16 bit) - Timer2 (8bit)</p>"},{"location":"Timer/#1-setting-up-timer1-option_reg-register","title":"1. Setting Up Timer1 <code>OPTION_REG</code> register","text":"<ul> <li>Set <code>prescale</code> of 8</li> </ul> <p><pre><code>    T1CKPS0 = 1;\n    T1CKPS1 = 1;\n</code></pre> - Enable Timer1</p> <pre><code>    TMR1ON = 1;\n</code></pre>"},{"location":"Timer/#2-set-up-the-interrupt-intcon-register","title":"2. Set up the Interrupt <code>INTCON</code> register","text":"<ul> <li>Enable Global an Peripheral interrupt</li> </ul> <pre><code>    GIE = 1; // enable global interrupt\n    PEIE = 1; // enable peripheral interrupt\n</code></pre> <ul> <li>Enable Timer1 <code>overflow</code> interupt</li> </ul> <pre><code>    TMR1IE = 1; // enable timer1 overflow interrupt\n</code></pre> <ul> <li>Clear the <code>interrupt flag</code> initially</li> </ul> <pre><code>    TMR1IF = 0; // clear timer1 overflow interrupt flag\n</code></pre>"},{"location":"Timer/#3-timer-value-calculation-for-the-desired-delay","title":"3. Timer value calculation for the desired delay","text":"<ul> <li><code>RegValue = 65536-((Delay * Fosc)/(Prescalar*4))</code></li> </ul> <pre><code>    TMR1H=0x9E;     // Load the time value(0xBDC) for 100 milli delay\n    TMR1L=0x58;\n</code></pre>"},{"location":"Timer/#4-writing-the-interrupt-service-routine-isr","title":"4. Writing the Interrupt Service Routine <code>ISR</code>","text":"<ul> <li>Clear overflow interrupt flag</li> <li>Reset timer value</li> </ul> <pre><code>void  __interrupt() isr(void) {\n    if(TMR1IF==1) {\n        TMR1H=0x9E;     // Load the time value(0xBDC) for 100 milli delay\n        TMR1L=0x58;\n        TMR1IF=0; // reset overflow flag\n        count++; // counter increments every 100 milli\n    } \n    return;\n}\n</code></pre>"},{"location":"Timer/#circuit-diagram","title":"Circuit Diagram:","text":""},{"location":"Timer/#license","title":"License","text":"<p>This work is licensed under GNU General Public License v3.0.</p>"}]}